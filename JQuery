In this tutorial, you will get a lot of jQuery examples to understand the topic well. Let's see a simple jQuery example.
File: firstjquery.html

    <!DOCTYPE html>  
    <html>  
    <head>  
     <title>First jQuery Example</title>  
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js">  
     </script>  
     <script type="text/javascript" language="javascript">  
     $(document).ready(function() {  
     $("p").css("background-color", "pink");  
     });  
     </script>  
     </head>  
    <body>  
    <p>This is first paragraph.</p>  
    <p>This is second paragraph.</p>  
    <p>This is third paragraph.</p>  
    </body>  
    </html>  



----------------------------------------------------------------------------------------------------
$(document).ready():



You cannot safely manipulate a page until the document is “ready.” jQuery detects this state of readiness for you; code included inside $(document).ready() will only run once the page is ready for JavaScript code to execute.

Example 3.1. A $(document).ready() block

$(document).ready(function() {
    console.log('ready!');
});


There is a shorthand for $(document).ready() that you will sometimes see; however, I recommend against using it if you are writing code that people who aren't experienced with jQuery may see.

Example 3.2. Shorthand for $(document).ready()

$(function() {
    console.log('ready!');
});


You can also pass a named function to $(document).ready() instead of passing an anonymous function.

Example 3.3. Passing a named function instead of an anonymous function

function readyFn() {
    // code to run when the document is ready
}


$(document).ready(readyFn);

-------------------------------------------------------------------------------
Selecting elements:

The most basic concept of jQuery is to “select some elements and do something with them.” jQuery supports most CSS3 selectors, as well as some non-standard selectors. For a complete selector reference, visit http://api.jquery.com/category/selectors/.

Following are a few examples of common selection techniques.
Example 3.4. Selecting elements by ID

$('#myId'); // note IDs must be unique per page


Example 3.5. Selecting elements by class name

$('div.myClass'); // performance improves if you specify element type


Example 3.6. Selecting elements by attribute

$('input[name=first_name]'); // beware, this can be very slow


Example 3.7. Selecting elements by compound CSS selector

$('#contents ul.people li');


Example 3.8. Pseudo-selectors

$('a.external:first'); 
$('tr:odd');
$('#myForm :input');   // select all input-like elements in a form
$('div:visible');
$('div:gt(2)');        // all except the first three divs
$('div:animated');     // all currently animated divs

Note

When you use the :visible and :hidden pseudo-selectors, jQuery tests the actual visibility of the element, not its CSS visibility or display — that is, it looks to see if the element's physical height and width on the page are both greater than zero. However, this test doesn't work with <tr> elements; in this case, jQuery does check the CSS display property, and considers an element hidden if its display property is set to none. Elements that have not been added to the DOM will always be considered hidden, even if the CSS that would affect them would render them visible. (See the Manipulation section later in this chapter to learn how to create and add elements to the DOM.)

For reference, here is the code jQuery uses to determine whether an element is visible or hidden, with comments added for clarity:

jQuery.expr.filters.hidden = function( elem ) {
    var width = elem.offsetWidth, height = elem.offsetHeight,
        skip = elem.nodeName.toLowerCase() === "tr";

    // does the element have 0 height, 0 width, 
    // and it's not a <tr>?
    return width === 0 && height === 0 && !skip ?

        // then it must be hidden
        true :

        // but if it has width and height 
        // and it's not a <tr>
        width > 0 && height > 0 && !skip ?

            // then it must be visible
            false :

            // if we get here, the element has width
            // and height, but it's also a <tr>,
            // so check its display property to
            // decide whether it's hidden
            jQuery.curCSS(elem, "display") === "none";
};

jQuery.expr.filters.visible = function( elem ) {
    return !jQuery.expr.filters.hidden( elem );
};

Choosing Selectors

Choosing good selectors is one way to improve the performance of your JavaScript. A little specificity — for example, including an element type such as div when selecting elements by class name — can go a long way. Generally, any time you can give jQuery a hint about where it might expect to find what you're looking for, you should. On the other hand, too much specificity can be a bad thing. A selector such as #myTable thead tr th.special is overkill if a selector such as #myTable th.special will get you what you want.

jQuery offers many attribute-based selectors, allowing you to make selections based on the content of arbitrary attributes using simplified regular expressions.

// find all <a>s whose rel attribute
// ends with "thinger"
$("a[rel$='thinger']");

While these can be useful in a pinch, they can also be extremely slow — I once wrote an attribute-based selector that locked up my page for multiple seconds. Wherever possible, make your selections using IDs, class names, and tag names.

Want to know more? Paul Irish has a great presentation about improving performance in JavaScript, with several slides focused specifically on selector performance.

Does My Selection Contain Any Elements?

Once you've made a selection, you'll often want to know whether you have anything to work with. You may be inclined to try something like:

if ($('div.foo')) { ... }

This won't work. When you make a selection using $(), an object is always returned, and objects always evaluate to true. Even if your selection doesn't contain any elements, the code inside the if statement will still run.

Instead, you need to test the selection's length property, which tells you how many elements were selected. If the answer is 0, the length property will evaluate to false when used as a boolean value.

Example 3.9. Testing whether a selection contains elements

if ($('div.foo').length) { ... }


Saving Selections

Every time you make a selection, a lot of code runs, and jQuery doesn't do caching of selections for you. If you've made a selection that you might need to make again, you should save the selection in a variable rather than making the selection repeatedly.

Example 3.10. Storing selections in a variable

var $divs = $('div');


Note

In Example 3.10, “Storing selections in a variable”, the variable name begins with a dollar sign. Unlike in other languages, there's nothing special about the dollar sign in JavaScript -- it's just another character. We use it here to indicate that the variable contains a jQuery object. This practice -- a sort of Hungarian notation -- is merely convention, and is not mandatory.

Once you've stored your selection, you can call jQuery methods on the variable you stored it in just like you would have called them on the original selection.
Note

A selection only fetches the elements that are on the page when you make the selection. If you add elements to the page later, you'll have to repeat the selection or otherwise add them to the selection stored in the variable. Stored selections don't magically update when the DOM changes.

Refining & Filtering Selections

Sometimes you have a selection that contains more than what you're after; in this case, you may want to refine your selection. jQuery offers several methods for zeroing in on exactly what you're after.

Example 3.11. Refining selections

$('div.foo').has('p');          // div.foo elements that contain <p>'s
$('h1').not('.bar');            // h1 elements that don't have a class of bar
$('ul li').filter('.current');  // unordered list items with class of current
$('ul li').first();             // just the first unordered list item
$('ul li').eq(5);               // the sixth 


Selecting Form Elements

jQuery offers several pseudo-selectors that help you find elements in your forms; these are especially helpful because it can be difficult to distinguish between form elements based on their state or type using standard CSS selectors.

:button

    Selects <button> elements and elements with type="button"
:checkbox

    Selects inputs with type="checkbox"
:checked

    Selects checked inputs
:disabled

    Selects disabled form elements
:enabled

    Selects enabled form elements
:file

    Selects inputs with type="file"
:image

    Selects inputs with type="image"
:input

    Selects <input>, <textarea>, and <select> elements
:password

    Selects inputs with type="password"
:radio

    Selects inputs with type="radio"
:reset

    Selects inputs with type="reset"
:selected

    Selects options that are selected
:submit

    Selects inputs with type="submit"
:text

    Selects inputs with type="text"

Example 3.12. Using form-related pseduo-selectors

$("#myForm :input'); // get all elements that accept input

---------------------------------------------------------------
Working with selectors:


Once you have a selection, you can call methods on the selection. Methods generally come in two different flavors: getters and setters. Getters return a property of the first selected element; setters set a property on all selected elements.
Chaining

If you call a method on a selection and that method returns a jQuery object, you can continue to call jQuery methods on the object without pausing for a semicolon.

Example 3.13. Chaining

$('#content').find('h3').eq(2).html('new text for the third h3!');


If you are writing a chain that includes several steps, you (and the person who comes after you) may find your code more readable if you break the chain over several lines.

Example 3.14. Formatting chained code

$('#content')
    .find('h3')
    .eq(2)
    .html('new text for the third h3!');


If you change your selection in the midst of a chain, jQuery provides the $.fn.end method to get you back to your original selection.

Example 3.15. Restoring your original selection using $.fn.end

$('#content')
    .find('h3')
    .eq(2)
        .html('new text for the third h3!')
    .end() // restores the selection to all h3's in #content
    .eq(0)
        .html('new text for the first h3!');


Note

Chaining is extraordinarily powerful, and it's a feature that many libraries have adapted since it was made popular by jQuery. However, it must be used with care. Extensive chaining can make code extremely difficult to modify or debug. There is no hard-and-fast rule to how long a chain should be -- just know that it is easy to get carried away.
Getters & Setters

jQuery “overloads” its methods, so the method used to set a value generally has the same name as the method used to get a value. When a method is used to set a value, it is called a setter. When a method is used to get (or read) a value, it is called a getter. Setters affect all elements in a selection; getters get the requested value only for the first element in the selection.

Example 3.16. The $.fn.html method used as a setter

$('h1').html('hello world');


Example 3.17. The html method used as a getter

$('h1').html();


Setters return a jQuery object, allowing you to continue to call jQuery methods on your selection; getters return whatever they were asked to get, meaning you cannot continue to call jQuery methods on the value returned by the getter.

---------------------------------------------
CSS, Styling, and Dimensions:


jQuery includes a handy way to get and set CSS properties of elements.
Note

CSS properties that normally include a hyphen need to be camel cased in JavaScript. For example, the CSS property font-size is expressed as fontSize in JavaScript.

Example 3.18. Getting CSS properties

$('h1').css('fontSize'); // returns a string such as "19px"


Example 3.19. Setting CSS properties

$('h1').css('fontSize', '100px'); // setting an individual property
$('h1').css({ 'fontSize' : '100px', 'color' : 'red' }); // setting multiple properties


Note the style of the argument we use on the second line -- it is an object that contains multiple properties. This is a common way to pass multiple arguments to a function, and many jQuery setter methods accept objects to set mulitple values at once.
Using CSS Classes for Styling

As a getter, the $.fn.css method is valuable; however, it should generally be avoided as a setter in production-ready code, because you don't want presentational information in your JavaScript. Instead, write CSS rules for classes that describe the various visual states, and then simply change the class on the element you want to affect.

Example 3.20. Working with classes

var $h1 = $('h1');

$h1.addClass('big');
$h1.removeClass('big');
$h1.toggleClass('big');

if ($h1.hasClass('big')) { ... }


Classes can also be useful for storing state information about an element, such as indicating that an element is selected.
Dimensions

jQuery offers a variety of methods for obtaining and modifying dimension and position information about an element.

The code in Example 3.21, “Basic dimensions methods” is just a very brief overview of the dimensions functionality in jQuery; for complete details about jQuery dimension methods, visit http://api.jquery.com/category/dimensions/.

Example 3.21. Basic dimensions methods

$('h1').width('50px');   // sets the width of all H1 elements
$('h1').width();         // gets the width of the first H1

$('h1').height('50px');  // sets the height of all H1 elements
$('h1').height();        // gets the height of the first H1

$('h1').position();      // returns an object containing position
                         // information for the first H1 relative to
                         // its "offset (positioned) parent"

----------------------------
Attributes: 


